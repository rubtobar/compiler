
//----------------------------------------------------
// The following code was generated by CUP v0.11b 20160615 (GIT 4ac7450)
//----------------------------------------------------

package compilador;

import compilador.Nodes.*;
import compilador.SymbolTable.*;
import java.util.ArrayList;
import compilador.SymbolTable.Description.DescriptionType;
import compilador.SymbolTable.Description.TSB;
import compilador.SyntaxTree.Param;
import compilador.SyntaxTree.ProcData;
import java.util.logging.Level;
import java.util.logging.Logger;
import java_cup.runtime.XMLElement;

/** CUP v0.11b 20160615 (GIT 4ac7450) generated parser.
  */
@SuppressWarnings({"rawtypes"})
public class Parser extends java_cup.runtime.lr_parser {

 public final Class getSymbolContainer() {
    return ParserSym.class;
}

  /** Default constructor. */
  @Deprecated
  public Parser() {super();}

  /** Constructor which sets the default scanner. */
  @Deprecated
  public Parser(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public Parser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\057\000\002\002\004\000\002\002\012\000\002\002" +
    "\012\000\002\003\002\000\002\004\004\000\002\004\002" +
    "\000\002\005\011\000\002\005\006\000\002\005\006\000" +
    "\002\010\004\000\002\010\006\000\002\010\004\000\002" +
    "\006\007\000\002\006\006\000\002\011\004\000\002\011" +
    "\002\000\002\012\004\000\002\012\004\000\002\012\004" +
    "\000\002\012\006\000\002\012\012\000\002\012\012\000" +
    "\002\012\004\000\002\013\005\000\002\013\005\000\002" +
    "\013\002\000\002\013\005\000\002\014\005\000\002\015" +
    "\007\000\002\016\004\000\002\016\002\000\002\017\004" +
    "\000\002\017\005\000\002\020\005\000\002\020\005\000" +
    "\002\021\005\000\002\021\003\000\002\022\005\000\002" +
    "\022\003\000\002\023\005\000\002\023\003\000\002\024" +
    "\005\000\002\024\003\000\002\024\003\000\002\024\003" +
    "\000\002\024\003\000\002\007\002" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\154\000\012\003\ufffe\017\ufffe\020\ufffe\025\ufffe\001" +
    "\002\000\004\002\156\001\002\000\012\003\uffe8\017\uffe8" +
    "\020\uffe8\025\uffe8\001\002\000\012\003\014\017\ufffc\020" +
    "\010\025\015\001\002\000\006\010\152\013\153\001\002" +
    "\000\004\025\146\001\002\000\004\014\145\001\002\000" +
    "\004\011\134\001\002\000\004\017\uffd3\001\002\000\006" +
    "\010\030\014\065\001\002\000\004\025\032\001\002\000" +
    "\004\014\031\001\002\000\010\003\020\017\ufffc\025\021" +
    "\001\002\000\004\010\030\001\002\000\004\025\023\001" +
    "\002\000\004\017\ufffd\001\002\000\004\007\024\001\002" +
    "\000\006\010\026\025\025\001\002\000\004\025\027\001" +
    "\002\000\004\011\ufff7\001\002\000\006\010\ufff5\013\ufff5" +
    "\001\002\000\004\011\ufff6\001\002\000\012\003\uffe9\017" +
    "\uffe9\020\uffe9\025\uffe9\001\002\000\010\007\024\014\uffe3" +
    "\021\033\001\002\000\012\004\035\006\041\007\036\025" +
    "\045\001\002\000\004\014\uffe6\001\002\000\016\010\uffd6" +
    "\013\uffd6\014\uffd6\022\uffd6\023\uffd6\024\uffd6\001\002\000" +
    "\012\004\035\006\041\007\036\025\045\001\002\000\014" +
    "\010\uffdd\013\uffdd\014\uffdd\023\054\024\uffdd\001\002\000" +
    "\016\010\uffd9\013\uffd9\014\uffd9\022\uffd9\023\uffd9\024\uffd9" +
    "\001\002\000\016\010\uffd5\013\uffd5\014\uffd5\022\uffd5\023" +
    "\uffd5\024\uffd5\001\002\000\006\010\060\013\061\001\002" +
    "\000\006\014\uffe4\024\052\001\002\000\016\010\uffdb\013" +
    "\uffdb\014\uffdb\022\056\023\uffdb\024\uffdb\001\002\000\020" +
    "\007\047\010\uffd7\013\uffd7\014\uffd7\022\uffd7\023\uffd7\024" +
    "\uffd7\001\002\000\016\010\uffd4\013\uffd4\014\uffd4\022\uffd4" +
    "\023\uffd4\024\uffd4\001\002\000\014\004\035\006\041\007" +
    "\036\010\050\025\045\001\002\000\016\010\uffe1\013\uffe1" +
    "\014\uffe1\022\uffe1\023\uffe1\024\uffe1\001\002\000\010\010" +
    "\uffe0\013\uffe0\024\052\001\002\000\012\004\035\006\041" +
    "\007\036\025\045\001\002\000\014\010\uffde\013\uffde\014" +
    "\uffde\023\054\024\uffde\001\002\000\012\004\035\006\041" +
    "\007\036\025\045\001\002\000\016\010\uffdc\013\uffdc\014" +
    "\uffdc\022\056\023\uffdc\024\uffdc\001\002\000\012\004\035" +
    "\006\041\007\036\025\045\001\002\000\016\010\uffda\013" +
    "\uffda\014\uffda\022\uffda\023\uffda\024\uffda\001\002\000\016" +
    "\010\uffe2\013\uffe2\014\uffe2\022\uffe2\023\uffe2\024\uffe2\001" +
    "\002\000\012\004\035\006\041\007\036\025\045\001\002" +
    "\000\010\010\uffdf\013\uffdf\024\052\001\002\000\006\010" +
    "\064\024\052\001\002\000\016\010\uffd8\013\uffd8\014\uffd8" +
    "\022\uffd8\023\uffd8\024\uffd8\001\002\000\012\003\uffe7\017" +
    "\uffe7\020\uffe7\025\uffe7\001\002\000\004\017\067\001\002" +
    "\000\004\011\070\001\002\000\016\003\075\012\ufff2\015" +
    "\076\016\074\020\010\025\077\001\002\000\004\012\133" +
    "\001\002\000\004\014\132\001\002\000\020\003\116\005" +
    "\ufff2\012\ufff2\015\076\016\074\020\010\025\077\001\002" +
    "\000\004\007\122\001\002\000\006\012\121\014\117\001" +
    "\002\000\004\007\110\001\002\000\010\007\047\021\104" +
    "\025\105\001\002\000\004\014\103\001\002\000\004\014" +
    "\102\001\002\000\020\003\uffef\005\uffef\012\uffef\015\uffef" +
    "\016\uffef\020\uffef\025\uffef\001\002\000\020\003\ufff1\005" +
    "\ufff1\012\ufff1\015\ufff1\016\ufff1\020\ufff1\025\ufff1\001\002" +
    "\000\012\004\035\006\041\007\036\025\045\001\002\000" +
    "\006\014\uffe3\021\033\001\002\000\006\014\107\024\052" +
    "\001\002\000\020\003\uffee\005\uffee\012\uffee\015\uffee\016" +
    "\uffee\020\uffee\025\uffee\001\002\000\012\004\035\006\041" +
    "\007\036\025\045\001\002\000\006\010\112\024\052\001" +
    "\002\000\004\011\uffd3\001\002\000\004\011\114\001\002" +
    "\000\016\003\116\012\ufff2\015\076\016\074\020\010\025" +
    "\077\001\002\000\004\012\120\001\002\000\004\014\117" +
    "\001\002\000\020\003\uffeb\005\uffeb\012\uffeb\015\uffeb\016" +
    "\uffeb\020\uffeb\025\uffeb\001\002\000\020\003\uffed\005\uffed" +
    "\012\uffed\015\uffed\016\uffed\020\uffed\025\uffed\001\002\000" +
    "\004\002\uffff\001\002\000\012\004\035\006\041\007\036" +
    "\025\045\001\002\000\006\010\124\024\052\001\002\000" +
    "\004\011\uffd3\001\002\000\004\011\126\001\002\000\016" +
    "\003\116\012\ufff2\015\076\016\074\020\010\025\077\001" +
    "\002\000\004\012\130\001\002\000\020\003\uffec\005\uffec" +
    "\012\uffec\015\uffec\016\uffec\020\uffec\025\uffec\001\002\000" +
    "\006\005\ufff3\012\ufff3\001\002\000\020\003\ufff0\005\ufff0" +
    "\012\ufff0\015\ufff0\016\ufff0\020\ufff0\025\ufff0\001\002\000" +
    "\004\002\000\001\002\000\020\003\136\005\ufff2\012\ufff2" +
    "\015\076\016\074\020\010\025\077\001\002\000\006\005" +
    "\140\012\141\001\002\000\006\012\137\014\117\001\002" +
    "\000\010\003\ufff9\017\ufff9\025\ufff9\001\002\000\012\004" +
    "\035\006\041\007\036\025\045\001\002\000\010\003\ufffa" +
    "\017\ufffa\025\ufffa\001\002\000\006\014\143\024\052\001" +
    "\002\000\004\012\144\001\002\000\010\003\ufffb\017\ufffb" +
    "\025\ufffb\001\002\000\012\003\uffea\017\uffea\020\uffea\025" +
    "\uffea\001\002\000\004\025\147\001\002\000\004\021\150" +
    "\001\002\000\012\004\035\006\041\007\036\025\045\001" +
    "\002\000\006\014\uffe5\024\052\001\002\000\004\011\ufff8" +
    "\001\002\000\004\025\154\001\002\000\004\025\155\001" +
    "\002\000\006\010\ufff4\013\ufff4\001\002\000\004\002\001" +
    "\001\002" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\154\000\006\002\003\003\004\001\001\000\002\001" +
    "\001\000\004\013\005\001\001\000\016\004\012\005\016" +
    "\006\006\010\011\014\010\015\015\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\004\007\065\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\012\004\021\005\016\006\006" +
    "\010\011\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\004\016\033\001\001\000\016" +
    "\017\045\020\041\021\042\022\036\023\043\024\037\001" +
    "\001\000\002\001\001\000\002\001\001\000\016\017\045" +
    "\020\041\021\062\022\036\023\043\024\037\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\016\017\045\020\041\021\050" +
    "\022\036\023\043\024\037\001\001\000\002\001\001\000" +
    "\002\001\001\000\014\017\045\020\041\022\052\023\043" +
    "\024\037\001\001\000\002\001\001\000\012\017\045\020" +
    "\041\023\054\024\037\001\001\000\002\001\001\000\010" +
    "\017\045\020\041\024\056\001\001\000\002\001\001\000" +
    "\002\001\001\000\016\017\045\020\041\021\061\022\036" +
    "\023\043\024\037\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\016\011\070\012\072\014\071\015" +
    "\100\017\077\020\041\001\001\000\002\001\001\000\002" +
    "\001\001\000\016\011\130\012\072\014\071\015\100\017" +
    "\077\020\041\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\016" +
    "\017\045\020\041\021\105\022\036\023\043\024\037\001" +
    "\001\000\004\016\033\001\001\000\002\001\001\000\002" +
    "\001\001\000\016\017\045\020\041\021\110\022\036\023" +
    "\043\024\037\001\001\000\002\001\001\000\004\007\112" +
    "\001\001\000\002\001\001\000\016\011\114\012\072\014" +
    "\071\015\100\017\077\020\041\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\016\017\045\020\041\021\122\022\036" +
    "\023\043\024\037\001\001\000\002\001\001\000\004\007" +
    "\124\001\001\000\002\001\001\000\016\011\126\012\072" +
    "\014\071\015\100\017\077\020\041\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\016\011\134\012\072\014\071\015" +
    "\100\017\077\020\041\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\016\017\045\020\041\021" +
    "\141\022\036\023\043\024\037\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\016" +
    "\017\045\020\041\021\150\022\036\023\043\024\037\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$Parser$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$Parser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$Parser$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 0;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}


  /** User initialization code. */
  public void user_init() throws java.lang.Exception
    {
 
    }

  /** Scan to get the next Symbol. */
  public java_cup.runtime.Symbol scan()
    throws java.lang.Exception
    {
 
		  Token t = scanner.getToken();
		  if (t == null){
		  	return new java_cup.runtime.Symbol(0);
		  }
		  return t.toSymbol();
		  
    }


    // Connect this parser to a scanner!
    public static ErrorPrinter errPrinter = compilador.Compilador.errPrinter;
    public static TreePrinter derTree = compilador.Compilador.derTree;
    compilador.Scanner scanner;
    SymbolTable st;
    SyntaxTree sytr;

    public Parser(Scanner scanner, SyntaxTree sytr){ 
    	this.scanner=scanner;
    	this.sytr = sytr;
    	st = new SymbolTable(sytr.getVt(), sytr.getPt());
    }


/** Cup generated class to encapsulate user supplied action code.*/
@SuppressWarnings({"rawtypes", "unchecked", "unused"})
class CUP$Parser$actions {
  private final Parser parser;

  /** Constructor */
  CUP$Parser$actions(Parser parser) {
    this.parser = parser;
  }

  /** Method 0 with the actual generated action code for actions 0 to 300. */
  public final java_cup.runtime.Symbol CUP$Parser$do_action_part00000000(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack            CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$Parser$result;

      /* select the action based on the action number */
      switch (CUP$Parser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // $START ::= PROG EOF 
            {
              Object RESULT =null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		NodeProg start_val = (NodeProg)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		RESULT = start_val;
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("$START",0, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          /* ACCEPT */
          CUP$Parser$parser.done_parsing();
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // PROG ::= INIT LDECL METHODS ENTERBLOCK tk_main tk_leftb SENTENCES tk_rightb 
            {
              NodeProg RESULT =null;
		int dclsleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)).left;
		int dclsright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)).right;
		NodeDecls dcls = (NodeDecls)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-6)).value;
		int mthdsleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).left;
		int mthdsright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).right;
		NodeMethods mthds = (NodeMethods)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-5)).value;
		int stcsleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int stcsright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		NodeSentences stcs = (NodeSentences)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
		try {
            st.exitBlock();
        } catch (IllegalBlockExitException ex) {
        }
		st.printOnFile();

		sytr.setRoot(new NodeProg(dcls, mthds, stcs, null));
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PROG",0, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // PROG ::= INIT LDECL METHODS ENTERBLOCK tk_main tk_leftb error tk_rightb 
            {
              NodeProg RESULT =null;
		int rbleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int rbright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Token rb = (Token)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
			errPrinter.badMainSyntax(rb.line, rb.column);
			try {
            	st.exitBlock();
	        } catch (IllegalBlockExitException ex) {
	        }
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PROG",0, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // INIT ::= 
            {
              Object RESULT =null;
		 
		try{

		Description d = new ProcDescription(TSB.VOID);
		st.add("main", d, true, false);

		d = new TypeDescription(TSB.BOOL, 2, 0, 1);
		st.add("boolean", d, true, false);

		st.add("true", new ConstDescription(TSB.BOOL, "TRUE"), true, false);
		st.add("false",  new ConstDescription(TSB.BOOL, "FALSE"), true, false);

		d = new TypeDescription(TSB.INT, 4, Integer.MIN_VALUE, Integer.MAX_VALUE);
		st.add("int", d, true, false);

		d = new TypeDescription(TSB.VOID, 0, 0, 0);
		st.add("void", d, true, false);

		d = new TypeDescription(TSB.STRING, 32, 0, 0);
		st.add("string", d, true, false);

		d = new ProcDescription(TSB.VOID);
		st.add("write@STRING", d, true, false);
		
		d = new ArgDescription("write@STRING", TSB.STRING);
		st.addParameter("write@STRING", "value", (ArgDescription) d);

		d = new ProcDescription(TSB.VOID);
		st.add("write@INT", d, true, false);
		
		d = new ArgDescription("write@INT", TSB.INT);
		st.addParameter("write@INT", "value", (ArgDescription) d);

		d = new ProcDescription(TSB.STRING);
		st.add("readString", d, true, false);

		d = new ProcDescription(TSB.INT);
		st.add("readInt", d, true, false);
		} catch (AlreadyDeclaredException | ReservedSymbolException | NoProcGivenException ex) {
            Logger.getLogger(Parser.class.getName()).log(Level.SEVERE, null, ex);
        }
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("INIT",1, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // METHODS ::= METHOD METHODS 
            {
              NodeMethods RESULT =null;
		int mthleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int mthright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		NodeMethod mth = (NodeMethod)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int mthsleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int mthsright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		NodeMethods mths = (NodeMethods)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
			RESULT = new NodeMethods(mth, mths, null);
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("METHODS",2, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // METHODS ::= 
            {
              NodeMethods RESULT =null;
		
		 	/*DONE*/ 
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("METHODS",2, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // METHOD ::= HEAD tk_leftb SENTENCES tk_return EXPR tk_pcoma tk_rightb 
            {
              NodeMethod RESULT =null;
		int nPleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)).left;
		int nPright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)).right;
		NodeHead nP = (NodeHead)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-6)).value;
		int stcsleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).left;
		int stcsright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).right;
		NodeSentences stcs = (NodeSentences)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-4)).value;
		int rtnleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int rtnright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Token rtn = (Token)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int etleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int etright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		NodeExpr et = (NodeExpr)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		
		try {
        st.exitBlock();
	    } catch (IllegalBlockExitException ex) {
	        Logger.getLogger(Parser.class.getName()).log(Level.SEVERE, null, ex);
	    }
	    if (nP != null) {
		    TblSymbol aux = st.get((String) nP.result);
			if (aux == null || et == null){/*ignora*/}
			else if (aux.d.tsb == TSB.VOID) {
				errPrinter.unexpectedReturn(rtn.line, rtn.column);
			} else if (aux.d.tsb != et.result) {
				errPrinter.unexpectedReturnType(rtn.line, rtn.column, (String) nP.result, aux.d.tsb.toString(), et.result.toString());
			}
			RESULT = new NodeMethod(nP, stcs, et, st.get((String)nP.result).id, null);
		}
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("METHOD",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // METHOD ::= HEAD tk_leftb SENTENCES tk_rightb 
            {
              NodeMethod RESULT =null;
		int nPleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int nPright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		NodeHead nP = (NodeHead)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int stcsleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int stcsright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		NodeSentences stcs = (NodeSentences)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int ccleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int ccright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Token cc = (Token)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
		try {
        st.exitBlock();
	    } catch (IllegalBlockExitException ex) {
	        Logger.getLogger(Parser.class.getName()).log(Level.SEVERE, null, ex);
	    }
	    if (nP != null) {
		    TblSymbol aux = st.get((String) nP.result);
		    if (aux == null){/*ignora*/}
		    else if (aux.d.tsb != TSB.VOID){
		    	errPrinter.missingReturn(cc.line, cc.column, (String) nP.result);
		    }

		    RESULT = new NodeMethod(nP, stcs, st.get((String)nP.result).id, null);
		}
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("METHOD",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // METHOD ::= HEAD tk_leftb error tk_rightb 
            {
              NodeMethod RESULT =null;
		int nPleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int nPright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		NodeHead nP = (NodeHead)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int lbleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int lbright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Token lb = (Token)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		
			errPrinter.badBlockInstructions(lb.line, lb.column, (String) nP.result);
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("METHOD",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // HEAD ::= CONT_HEAD tk_closep 
            {
              NodeHead RESULT =null;
		int nPleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int nPright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		NodeContHead nP = (NodeContHead)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int cpleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int cpright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Token cp = (Token)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
		if (nP != null) {
			/* Add method and params to tables */
			ProcData data = (ProcData)nP.result;
			String name = data.name;
			try {
			    st.add(name, new ProcDescription(data.returnType), false, false);
	        } catch (AlreadyDeclaredException ex) {
	            errPrinter.alreadyDeclaredFunction(cp.line, cp.column, data.name);
	        } catch (ReservedSymbolException ex) {
	            errPrinter.reservedFunctionName(cp.line, cp.column, data.name);
	        }
			for (Param param : data.params) {
				try {
					st.addParameter(name, param.name, new ArgDescription(param.name, param.type));
				} catch (NoProcGivenException ex) {
	            // Ignorar
	            } catch (AlreadyDeclaredException ex) {
	                errPrinter.alreadyDeclaredArgument(cp.line, cp.column, data.name, param.name);
	            } catch (ReservedSymbolException ex) {
	                errPrinter.reservedArgumentName(cp.line, cp.column, data.name, param.name);
	            }
			}
			/* Create symbols for method evaluation */
			st.enterBlock();
			TblSymbol aux = st.get(data.name);
			if (aux != null  && aux.d.dt == DescriptionType.DPROC) {		
				int arg = ((ProcDescription)aux.d).firstArg;
		        while (arg != 0 ){
		            aux = st.getParameter(arg);
		            try {
		                st.add(aux.lexema, new VarDescription(aux.d.tsb), false, true);
		            } catch (AlreadyDeclaredException ex) {
		                Logger.getLogger(Parser.class.getName()).log(Level.SEVERE, null, ex);
		            } catch (ReservedSymbolException ex) {
		            }
		            arg = ((ArgDescription)aux.d).next;
		        }
				RESULT = new NodeHead(nP,data.name);
			} else {
				RESULT = new NodeHead(nP,"");
			}
		} else {
			st.enterBlock();
		}
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("HEAD",6, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // HEAD ::= tk_id tk_id tk_openp tk_closep 
            {
              NodeHead RESULT =null;
		int tipusleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int tipusright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Token tipus = (Token)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int nomleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int nomright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Token nom = (Token)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		
		TblSymbol aux = st.get(tipus.getAtribut());
		if (aux == null || aux.d.dt != DescriptionType.DTYPE) {
            errPrinter.nonExistingType(tipus.line, tipus.column, tipus.getAtribut());
        } else {
        	try {
	            st.add(nom.getAtribut(), new ProcDescription(aux.d.tsb), false, false);
	            RESULT = new NodeHead(null, nom.getAtribut());
	        } catch (AlreadyDeclaredException ex) {
                errPrinter.alreadyDeclaredFunction(nom.line, nom.column, nom.getAtribut());
	        } catch (ReservedSymbolException ex) {
                errPrinter.reservedFunctionName(nom.line, nom.column, nom.getAtribut());
	        }
        }
        st.enterBlock();
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("HEAD",6, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // HEAD ::= error tk_closep 
            {
              NodeHead RESULT =null;
		int cpleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int cpright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Token cp = (Token)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
			errPrinter.unexpectedArguments(cp.line, cp.column);
			st.enterBlock();
			RESULT = new NodeHead(null, "");
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("HEAD",6, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // CONT_HEAD ::= tk_id tk_id tk_openp tk_id tk_id 
            {
              NodeContHead RESULT =null;
		int tPleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).left;
		int tPright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).right;
		Token tP = (Token)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-4)).value;
		int nPleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int nPright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Token nP = (Token)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int tAleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int tAright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Token tA = (Token)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int nAleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int nAright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Token nA = (Token)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
		TblSymbol aux = st.get(tP.getAtribut());
		Description.TSB returnType = null;
		if (aux == null || aux.d.dt != DescriptionType.DTYPE) {
            errPrinter.nonExistingType(tP.line, tP.column, tP.getAtribut());
        } else {
        	returnType = aux.d.tsb;
        }
        aux = st.get(tA.getAtribut());
        if (aux == null || aux.d.dt != DescriptionType.DTYPE) {
            errPrinter.nonExistingType(tA.line, tA.column, tA.getAtribut());
        } else if (returnType != null){
        	String newName = nP.getAtribut()+"@"+aux.d.tsb;
        	ArrayList <Param> params = new ArrayList();
        	params.add(new Param(nA.getAtribut(), aux.d.tsb));
        	RESULT = new NodeContHead(null, new ProcData(newName, returnType, params));
        }
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("CONT_HEAD",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // CONT_HEAD ::= CONT_HEAD tk_coma tk_id tk_id 
            {
              NodeContHead RESULT =null;
		int procleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int procright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		NodeContHead proc = (NodeContHead)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int tipusleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int tipusright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Token tipus = (Token)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int nomleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int nomright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Token nom = (Token)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
		TblSymbol aux = st.get(tipus.getAtribut());
        if (aux == null || aux.d.dt != DescriptionType.DTYPE) { 
            errPrinter.nonExistingType(tipus.line, tipus.column, tipus.getAtribut());
        } else if (proc != null){
        	ProcData data = (ProcData)proc.result;
        	data.name = data.name+"@"+aux.d.tsb;
        	data.params.add(new Param(nom.getAtribut(), aux.d.tsb));
            RESULT = new NodeContHead(proc, data);
        }
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("CONT_HEAD",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // SENTENCES ::= SENTENCE SENTENCES 
            {
              NodeSentences RESULT =null;
		int stcleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int stcright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Node stc = (Node)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int stcsleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int stcsright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		NodeSentences stcs = (NodeSentences)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
		RESULT = new NodeSentences(stc,stcs,null);
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SENTENCES",7, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // SENTENCES ::= 
            {
              NodeSentences RESULT =null;
		
			/* DONE */ 
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SENTENCES",7, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // SENTENCE ::= CALL tk_pcoma 
            {
              Node RESULT =null;
		int cllleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int cllright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		NodeCall cll = (NodeCall)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
		RESULT = cll;
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SENTENCE",8, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // SENTENCE ::= DECL tk_pcoma 
            {
              Node RESULT =null;
		int dclleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int dclright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		NodeDecl dcl = (NodeDecl)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 
		RESULT = dcl;
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SENTENCE",8, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // SENTENCE ::= CONST_DECL tk_pcoma 
            {
              Node RESULT =null;
		int cdclleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int cdclright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		NodeConstDecl cdcl = (NodeConstDecl)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 
		RESULT = cdcl;
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SENTENCE",8, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // SENTENCE ::= tk_id tk_equal EXPR tk_pcoma 
            {
              Node RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int eqleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int eqright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Token eq = (Token)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int teleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int teright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		NodeExpr te = (NodeExpr)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		

		TblSymbol aux = st.get(id.getAtribut());
        if (aux == null) {
            errPrinter.undeclaredVariable(id.line, id.column, id.getAtribut());
        } else if (aux.d.dt == DescriptionType.DCONST){
            errPrinter.assigmentToConst(id.line, id.column, id.getAtribut());
        } else if (aux.d.dt != DescriptionType.DVAR) {
            errPrinter.undeclaredVariable(id.line, id.column, id.getAtribut());
        }else if (te == null) {
            // Ignorar
        } else if (te.result != aux.d.tsb) {
            errPrinter.unexpectedValueType(eq.line, eq.column, te.result.toString(), aux.d.tsb.toString());
        } else {
			RESULT = new NodeAssignation(aux.id, te, null);
        }
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SENTENCE",8, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // SENTENCE ::= tk_if tk_openp EXPR tk_closep ENTERBLOCK tk_leftb SENTENCES tk_rightb 
            {
              Node RESULT =null;
		int oppleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)).left;
		int oppright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)).right;
		Token opp = (Token)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-6)).value;
		int condleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).left;
		int condright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).right;
		NodeExpr cond = (NodeExpr)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-5)).value;
		int stcsleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int stcsright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		NodeSentences stcs = (NodeSentences)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
		try {
        	st.exitBlock();
        } catch (IllegalBlockExitException ex) {
        	Logger.getLogger(Parser.class.getName()).log(Level.SEVERE, null, ex);
        }
		if (cond == null) {
			// Ignorar
		}
		else if (cond.result != TSB.BOOL){
			errPrinter.notALogicStatement(opp.line, opp.column, (String) cond.result);
		} else {
			RESULT = new NodeIf(cond,stcs,null);
		}
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SENTENCE",8, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // SENTENCE ::= tk_while tk_openp EXPR tk_closep ENTERBLOCK tk_leftb SENTENCES tk_rightb 
            {
              Node RESULT =null;
		int oppleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)).left;
		int oppright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)).right;
		Token opp = (Token)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-6)).value;
		int condleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).left;
		int condright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).right;
		NodeExpr cond = (NodeExpr)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-5)).value;
		int stcsleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int stcsright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		NodeSentences stcs = (NodeSentences)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
		try {
        	st.exitBlock();
        } catch (IllegalBlockExitException ex) {
        	Logger.getLogger(Parser.class.getName()).log(Level.SEVERE, null, ex);
        }
		if (cond == null || cond.result == null) {
			// Ignorar
		}
		else if (cond.result != TSB.BOOL){
			errPrinter.notALogicStatement(opp.line, opp.column, (String) cond.result);
		} else {
			RESULT = new NodeWhile(cond,stcs,null);
		}
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SENTENCE",8, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // SENTENCE ::= error tk_pcoma 
            {
              Node RESULT =null;
		int pcleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int pcright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Token pc = (Token)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
			errPrinter.unexpectedSentence(pc.line, pc.column);
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SENTENCE",8, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // LDECL ::= LDECL DECL tk_pcoma 
            {
              NodeDecls RESULT =null;
		int ldeleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int lderight = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		NodeDecls lde = (NodeDecls)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int deleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int deright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		NodeDecl de = (NodeDecl)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 

		RESULT = new NodeDecls(lde,(NodeDecl)de,null);
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("LDECL",9, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // LDECL ::= LDECL CONST_DECL tk_pcoma 
            {
              NodeDecls RESULT =null;
		int ldeleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int lderight = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		NodeDecls lde = (NodeDecls)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int cdeleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int cderight = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		NodeConstDecl cde = (NodeConstDecl)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 

		RESULT = new NodeDecls(lde,(NodeConstDecl)cde,null);
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("LDECL",9, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // LDECL ::= 
            {
              NodeDecls RESULT =null;
		
		 	/* DONE */
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("LDECL",9, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // LDECL ::= LDECL error tk_pcoma 
            {
              NodeDecls RESULT =null;
		int pcleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int pcright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Token pc = (Token)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
			errPrinter.badDeclaration(pc.line, pc.column);
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("LDECL",9, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // DECL ::= tk_id tk_id ASSIGN 
            {
              NodeDecl RESULT =null;
		int tipusleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int tipusright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Token tipus = (Token)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int nomleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int nomright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Token nom = (Token)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int vtleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int vtright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		NodeAssign vt = (NodeAssign)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
		TblSymbol aux = st.get(tipus.getAtribut());
	    if (aux == null || aux.d.dt != DescriptionType.DTYPE) {
            errPrinter.nonExistingType(tipus.line, tipus.column, tipus.getAtribut());
	    } else {
	        if (vt == null) {
	        	//ingorar
	        } else if (vt.result.getClass() != Boolean.class && vt.result != aux.d.tsb) {
                errPrinter.unexpectedValueType(nom.line, nom.column, vt.result.toString(), aux.d.tsb.toString());
	        } 
	        try {
            	int id = st.add(nom.getAtribut(), new VarDescription(aux.d.tsb), false, false);
            	RESULT = new NodeDecl(vt, id, null);
            } catch (AlreadyDeclaredException ex) {
                errPrinter.alreadyDeclaredVariable(nom.line, nom.column, nom.getAtribut());
            } catch (ReservedSymbolException ex) {
                errPrinter.reservedVariableName(nom.line, nom.column, nom.getAtribut());
            }
	    }
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("DECL",10, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // CONST_DECL ::= tk_const tk_id tk_id tk_equal EXPR 
            {
              NodeConstDecl RESULT =null;
		int tipusleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int tipusright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Token tipus = (Token)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int nomleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int nomright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Token nom = (Token)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int eqleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int eqright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Token eq = (Token)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int etleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int etright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		NodeExpr et = (NodeExpr)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
		TblSymbol aux = st.get(tipus.getAtribut());
        if (aux == null || aux.d.dt != DescriptionType.DTYPE) {
            errPrinter.nonExistingType(tipus.line, tipus.column, tipus.getAtribut());
        } else if (et == null) {
        	//ingorar
        } else if (et.result.getClass() != Boolean.class && et.result != aux.d.tsb) {
            errPrinter.unexpectedValueType(eq.line, eq.column, et.result.toString(), aux.d.tsb.toString());
        } else {
            try {
            	st.add(nom.getAtribut(), new ConstDescription(aux.d.tsb, "v"+et.tid), false, false);
            	RESULT = new NodeConstDecl(et,null);
            } catch (AlreadyDeclaredException ex) {
                errPrinter.alreadyDeclaredVariable(nom.line, nom.column, nom.getAtribut());
            } catch (ReservedSymbolException ex) {
                errPrinter.reservedVariableName(nom.line, nom.column, nom.getAtribut());
            }
    	}
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("CONST_DECL",11, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // ASSIGN ::= tk_equal EXPR 
            {
              NodeAssign RESULT =null;
		int etleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int etright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		NodeExpr et = (NodeExpr)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
		if (et != null) {
			RESULT = new NodeAssign(et,et.result);
		}
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ASSIGN",12, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // ASSIGN ::= 
            {
              NodeAssign RESULT =null;
		 
			RESULT = new NodeAssign(null, new Boolean(false)); 
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ASSIGN",12, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // CALL ::= CONT_CALL tk_closep 
            {
              NodeCall RESULT =null;
		int paramsleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int paramsright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		NodeContCall params = (NodeContCall)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int clpleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int clpright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Token clp = (Token)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
        ArrayList <TSB> paramList = (ArrayList <TSB>) params.result;
        String procName = params.proc;
        int procId = 
        TblSymbol aux = st.get(procName);
        if (aux == null || aux.d.dt != DescriptionType.DPROC) {
            errPrinter.undeclaredFunction(clp.line, clp.column, procName);
        }
        else {
        	int tid;
        	TSB returnType = aux.d.tsb;
        	if (returnType != TSB.VOID) {
            	tid = st.addTemp(returnType);
           	}
	        RESULT = new NodeCall(params, procName, tid, returnType);
        }
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("CALL",13, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // CALL ::= tk_id tk_openp tk_closep 
            {
              NodeCall RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
			
		TblSymbol aux = st.get(id.getAtribut());
		if (aux == null || aux.d.dt != DescriptionType.DPROC) {
            errPrinter.undeclaredFunction(id.line, id.column, id.getAtribut());
		} else if (((ProcDescription) aux.d).firstArg != 0) { 
            errPrinter.tooFewArgs(id.line, id.column, id.getAtribut());
		} else {
		    Integer tid = null;
        	if (aux.d.tsb != TSB.VOID) {
        		tid = st.addTemp(aux.d.tsb);
        	}
			RESULT = new NodeCall(null, aux.id, tid, ((ProcDescription) aux.d).tsb);
		}
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("CALL",13, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // CONT_CALL ::= tk_id tk_openp EXPR 
            {
              NodeContCall RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int oppleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int oppright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Token opp = (Token)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int arg1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int arg1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		NodeExpr arg1 = (NodeExpr)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
			
        if (arg1 != null){
        	ArrayList<TSB> paramList = new ArrayList<>();
        	TSB paramType = (TSB) arg1.result;
        	paramList.add(paramType);
        	RESULT = new NodeContCall(id.getAtribut()+"@"+paramType, arg1, null, paramList);
        }
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("CONT_CALL",14, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // CONT_CALL ::= CONT_CALL tk_coma EXPR 
            {
              NodeContCall RESULT =null;
		int paramsleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int paramsright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		NodeContCall params = (NodeContCall)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int paramleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int paramright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		NodeExpr param = (NodeExpr)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    	((ArrayList<TSB>)params.result).add((TSB)param.result);
    	RESULT = new NodeContCall(params.proc+"@"+(TSB)param.result, param, params, params.result);
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("CONT_CALL",14, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // EXPR ::= EXPR tk_op_log LOG_EXPR 
            {
              NodeExpr RESULT =null;
		int etleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int etright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		NodeExpr et = (NodeExpr)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Token op = (Token)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int vtleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int vtright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		NodeLogExpr vt = (NodeLogExpr)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
		if (et == null || vt == null) {
			// Ignorar
		} else if (et.result != TSB.BOOL) {
            errPrinter.unexpectedValueType(op.line, op.column, et.result.toString(), TSB.BOOL.toString());
		} else if (vt.result != TSB.BOOL) {
            errPrinter.unexpectedValueType(op.line, op.column, vt.result.toString(), TSB.BOOL.toString());
        } else {
        	int tid = st.addTemp(TSB.BOOL);
        	RESULT = new NodeExpr(et,vt,tid,op.getAtribut(),TSB.BOOL);
        }
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("EXPR",15, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // EXPR ::= LOG_EXPR 
            {
              NodeExpr RESULT =null;
		int vtleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int vtright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		NodeLogExpr vt = (NodeLogExpr)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
		if (vt != null) {
			RESULT = new NodeExpr(null, vt, vt.tid, null, vt.result);
		}
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("EXPR",15, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // LOG_EXPR ::= LOG_EXPR tk_op_rel AR_EXPR 
            {
              NodeLogExpr RESULT =null;
		int etleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int etright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		NodeLogExpr et = (NodeLogExpr)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Token op = (Token)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int vtleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int vtright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		NodeArExpr vt = (NodeArExpr)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
		if (et == null || vt == null) {
			// Ignorar
		} else if (et.result != TSB.INT) {
            errPrinter.unexpectedValueType(op.line, op.column, et.result.toString(), TSB.INT.toString());
		} else if (vt.result != TSB.INT){
            errPrinter.unexpectedValueType(op.line, op.column, vt.result.toString(), TSB.INT.toString());
        } else {
        	int tid = st.addTemp(TSB.BOOL);
        	RESULT = new NodeLogExpr(et,vt,tid,op.getAtribut(),TSB.BOOL);
		}
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("LOG_EXPR",16, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // LOG_EXPR ::= AR_EXPR 
            {
              NodeLogExpr RESULT =null;
		int vtleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int vtright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		NodeArExpr vt = (NodeArExpr)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
			if (vt != null) {
				RESULT = new NodeLogExpr(null,vt,vt.tid,null,vt.result);
			}
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("LOG_EXPR",16, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // AR_EXPR ::= AR_EXPR tk_op_aritm VALUE 
            {
              NodeArExpr RESULT =null;
		int etleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int etright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		NodeArExpr et = (NodeArExpr)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Token op = (Token)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int vtleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int vtright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		NodeValue vt = (NodeValue)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
		if (et == null || vt == null) {
            // Ignorar
		} else if (et.result != TSB.INT) {
            errPrinter.unexpectedValueType(op.line, op.column, et.result.toString(), TSB.INT.toString());
		} else if (vt.result != TSB.INT){ 
            errPrinter.unexpectedValueType(op.line, op.column, vt.result.toString(), TSB.INT.toString());
        } else {
            int tid = st.addTemp(TSB.INT);
        	RESULT = new NodeArExpr(et, vt, op.getAtribut(), tid, TSB.INT);
		}
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("AR_EXPR",17, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // AR_EXPR ::= VALUE 
            {
              NodeArExpr RESULT =null;
		int vtleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int vtright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		NodeValue vt = (NodeValue)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
		if (vt != null) {
			RESULT = new NodeArExpr(null, vt, null, vt.id, vt.result); 
		}
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("AR_EXPR",17, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // VALUE ::= tk_openp EXPR tk_closep 
            {
              NodeValue RESULT =null;
		int exprleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		NodeExpr expr = (NodeExpr)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 
		RESULT = new NodeValue(expr, null, expr.tid, null, expr.result);
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("VALUE",18, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // VALUE ::= tk_id 
            {
              NodeValue RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
			
		TblSymbol aux = st.get(id.getAtribut()); 
		if (aux == null || (aux.d.dt != DescriptionType.DVAR && aux.d.dt != DescriptionType.DCONST)) {
            errPrinter.undeclaredVariable(id.line, id.column, id.getAtribut());
        } else {
        	if (aux.d.dt == DescriptionType.DCONST) {
        		int tid = st.addTemp(aux.d.tsb);
        		RESULT = new NodeValue(null, null, tid, ((ConstDescription)aux.d).constValue, aux.d.tsb);
        	} else {
        		RESULT = new NodeValue(null, null, aux.id, null, aux.d.tsb);
        	}
        }
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("VALUE",18, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // VALUE ::= tk_string 
            {
              NodeValue RESULT =null;
		int strleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int strright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Token str = (Token)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
		int tid = st.addTemp(TSB.STRING);
		RESULT = new NodeValue(null, null, tid, "'"+str.getAtribut(), TSB.STRING);
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("VALUE",18, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // VALUE ::= tk_digits 
            {
              NodeValue RESULT =null;
		int digleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int digright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Token dig = (Token)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
			
		try{
			Integer value = Integer.parseInt(dig.getAtribut());
			int tid = st.addTemp(TSB.INT);
			RESULT = new NodeValue(null, null, tid, value.toString(), TSB.INT);
		}catch(NumberFormatException e){
            errPrinter.overflow(dig.line, dig.column, dig.getAtribut());
		}
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("VALUE",18, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // VALUE ::= CALL 
            {
              NodeValue RESULT =null;
		int callleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int callright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		NodeCall call = (NodeCall)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
		if (call != null) {
			RESULT = new NodeValue(null, call, null, null, call.result); 
		}
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("VALUE",18, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // ENTERBLOCK ::= 
            {
              Object RESULT =null;
		 st.enterBlock(); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ENTERBLOCK",5, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number "+CUP$Parser$act_num+"found in internal parse table");

        }
    } /* end of method */

  /** Method splitting the generated action code into several parts. */
  public final java_cup.runtime.Symbol CUP$Parser$do_action(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack            CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
              return CUP$Parser$do_action_part00000000(
                               CUP$Parser$act_num,
                               CUP$Parser$parser,
                               CUP$Parser$stack,
                               CUP$Parser$top);
    }
}

}
